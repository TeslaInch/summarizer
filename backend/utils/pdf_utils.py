# utils/pdf_utils.py
import fitz  # PyMuPDF
import pikepdf
from io import BytesIO
import logging

logger = logging.getLogger(__name__)

# Common scanner watermarks and junk patterns
SCANNER_PATTERNS = {
    'CamScanner','camscanner', 'scan', 'scanned', 'document scanner', 'tiny scanner',
    'adf', 'flatbed', 'preview', 'draft', 'created by', 'converted by',
    'scanned by', 'generated by', 'image only', 'no text'
}

JUNK_PHRASES = {
    'this is a scanned copy', 'no text available', 'please check original',
    'image only', 'cannot extract text', 'do not print', 'confidential'
}

def is_junk_text(text: str) -> bool:
    """Detect if text is meaningless (scanner watermark, repetition, etc.)"""
    if not text or len(text.strip()) < 10:
        return True

    text_lower = text.lower()
    
    # Blocklist: scanner-related patterns
    scanner_keywords = {
        'camscanner', 'scanbot', 'adobe scan', 'microsoft lens',
        'scanner', 'scanned by', 'created by', 'converted by',
        'document scanner', 'tiny scanner', 'mobilepdf', 'pdf now'
    }
    
    # If any scanner keyword appears more than 3 times → junk
    word_count = text_lower.split()
    scanner_matches = [w for w in word_count if any(k in w for k in scanner_keywords)]
    if len(scanner_matches) > 3:
        return True

    # Check for high repetition
    from collections import Counter
    freq = Counter(word_count)
    if len(freq) < len(word_count) / 3:  # Too many duplicates
        return True

    # Check for known junk phrases
    junk_phrases = {
        'this is a scanned copy', 'no text available', 'please check original',
        'image only', 'cannot extract text', 'do not print', 'draft'
    }
    if any(phrase in text_lower for phrase in junk_phrases):
        return True

    # Not obviously junk
    return False

def count_meaningful_words(text: str) -> int:
    """Count unique, non-junk words"""
    if not text:
        return 0
    words = [
        w.strip('.,:;()').lower() 
        for w in text.split() 
        if len(w.strip('.,:;()')) > 2
    ]
    meaningful = [w for w in words if w not in SCANNER_PATTERNS]
    return len(meaningful)

def extract_text_from_pdf(content: bytes) -> str:
    """
    Extract text from a native PDF.
    Rejects scanned, low-content, or junk-filled PDFs.
    """
    # Validate PDF structure
    try:
        with pikepdf.Pdf.open(BytesIO(content)) as pdf:
            pass
    except Exception as e:
        logger.warning(f"PDF validation failed: {e}")
        return "Invalid or scanned PDF: Could not validate PDF structure."

    try:
        doc = fitz.open(stream=content, filetype="pdf")
        all_text = []

        for page_num in range(doc.page_count):
            page = doc[page_num]
            text = page.get_text().strip()

            if not text:
                continue

            if is_junk_text(text):
                doc.close()
                return "Scanned PDFs are not supported. Please upload a text-based PDF."

            all_text.append(text)

        doc.close()

        full_text = "\n\n".join(all_text).strip()

        if not full_text or is_junk_text(full_text):
            return "Scanned PDFs are not supported. Please upload a text-based PDF."
        # ✅ NEW: Reject if too short
        word_count = count_meaningful_words(full_text)
        if word_count < 50:
            logger.info(f"PDF rejected: only {word_count} meaningful words found")
            return (
                "Document too short or low-quality. "
                "Please upload a more detailed text-based PDF with meaningful content."
            )

        # Final junk check on full text
        if is_junk_text(full_text):
            return "Scanned or low-quality PDF. Please upload a proper text-based document."

        return full_text

    except Exception as e:
        logger.error(f"Text extraction failed: {e}")
        return "Could not extract text from PDF. The file may be corrupted."